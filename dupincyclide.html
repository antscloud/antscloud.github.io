<!doctype html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="fontawesome-free-5.13.0-web/fontawesome-free-5.13.0-web/css/all.min.css">
    <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/dupincyclide.css">
    <link rel="stylesheet" href="js/highlight/styles/atom-one-light.css">
    <link rel="icon" type="image/png" href="image/SVG/yellow.svg" />
    <title>Cyclide de Dupin</title>
</head>


<body>
    <!-- HEADER  -->
    <div id='container-top-svg'>
        <div id="svg-triangle">
            <svg height="75" width="200">
                <polygon points="0,0 200,0 100,75" style="fill:#037B89;" />
            </svg>
        </div>
        <div class="container-fluid" id="topnav">
            <nav>
                <div class="d-flex align-items-center justify-content-center">
                    <div class="mr-auto">
                        <a href="index.html">Antoine Gibek</a>
                    </div>
                    <div class="d-flex">

                        <div class='logotop'>
                            <div class="d-flex flex-column justify-content-center align-items-center">
                                <a class="d-flex justify-content-center align-items-center"
                                    href="https://www.linkedin.com/in/antoine-gibek-7739a9169/"><i
                                        class="fab fa-linkedin"></i></a>
                            </div>

                            <div class="d-flex flex-column justify-content-center align-items-center">
                                <a class="d-flex justify-content-center align-items-center"
                                    href="https://github.com/antscloud/"><i class="fab fa-github"></i></a>
                            </div>
                        </div>

                        <a id='contactbutton' href="#contact">Contact</a>
                    </div>
            </nav>
        </div>

    </div>

    <!-- HEADER -->

    <div class="container">
        <div class="row part-content">
            <div class="d-flex align-items-center justify-content-center w-100" id="titleofproject">

                <div class="mr-auto">
                    <h1><i class="fas fa-chevron-right chevron-color"></i> Cyclides de Dupin et cristaux liquides</h1>
                </div>

                <div class="d-flex align-items-center justify-content-center" id="logoright">
                    <span>Voir le code source</span>
                    <a href="https://github.com/antscloud/dupincyclide"><i class="fab fa-github"> </i></a>
                </div>

            </div>
        </div>

        <div class='row part-content' id="principe-util-box">

            <div class="d-flex justify-content-between w-100 flex-wrap" id='principe-util'>
                <div class='d-flex justify-content-center'><b>Numpy</b></div>
                <div class='d-flex justify-content-center'><b>Rotplot</b></div>
                <div class='d-flex justify-content-center'><b>Mathématique</b></div>
            </div>

        </div>
        <div class="row part-content">
            <p>Lors de mon stage de Licence que j'ai effectué avec Claire Meyer (Professeure et chercheuse au
                laboratoire des systèmes complexes de l'UPJV), il m'a été confié de modéliser des Cyclides de Dupin
                basées sur des ellipses elles même pavées autour d'un cône.
                Les cristaux liquides sont des sortes de petits bâtonnets bien organisés, souvent en couche,
                répondant à une physique différentes des matériaux usuels sur des paramètres tels que la viscosité,
                leur réponse à un champ électrique et autre.
                Dans certaines circonstances et configurations spécifiques, ces bâtonnets s'organisent et
                s'orientent dans une géométrie bien particulière. Dans certaines d'entre elles, les couches de cristaux liquides viennent
                naturellement, par minimisation d'énérgie, s'orienter perpendiculairement à des surfaces que l'on
                appelle les Cyclides de Dupin. Les Cyclides de dupin constituent une généralisation du tore. En effet,
                si on coupe un tore verticalement on obtient un cercle qui fait la même taille peu importe où il sera
                coupé (comme un Paris-Brest par exemple.) Pour les Cyclide de Dupin cela est différent, le rayon du
                cercle découpé sera différente selon où l'on coupe.

                Voici un exemple :

            <div class="d-flex align-items-center justify-content-center w-100">
                <img src="image/cyclidewiki.png" alt="Cyclide de Dupin wikipédia">
            </div>

            Plus précisément, dans le cas des cristaux liquides, on considère une ellipse, à l'un des foyers ce cette
            ellipse, nous faisons passer une hyperbole dont le maximum est au dit foyer. Les Cyclides de Dupin vont
            venir "s'enrouler" en quelque sorte autour de cette ellipse en suivant l'hyperbole. Une image sera
            sûrement plus parlante :

            <div class="d-flex align-items-center justify-content-center flex-column w-100" id='articledupin'>
                <img src="image/dupinellipse.jpg" alt="article dupin cyclide">
                <span> Schief, W. K., Kleman, M., & Rogers, C. (2005). On a nonlinear elastic shell system in liquid
                    crystal theory: Generalized Willmore surfaces and Dupin cyclides. Proceedings of the Royal
                    Society A: Mathematical, Physical and Engineering Sciences, 461(2061), 2817-2837.</span>
            </div>

            Dans notre cas l'image suivante a été observée lors d'une expérience consistant à placer un certain type
            de cristal liquide sous un champ électrique variable ainsi qu'une température variable.

            <div class="d-flex align-items-center justify-content-center w-100">
                <div class="row">
                    <div class="d-flex align-items-center justify-content-center  col-lg-6 col-sm-12">
                        <img src="image/dupin.PNG" alt="Cyclide de Dupin Cristal liquide">
                    </div>
                    <div class="d-flex align-items-center justify-content-center col-lg-6 col-sm-12">
                        <img src="image/Dupindraw.png" alt="Dupin Annoté">
                    </div>
                </div>
            </div>

            En rouge, nous pouvons voir une hyperbole qui passe par le foyer d'une ellipse (vu de champ). Sur cette
            ellipse se trouve un cone (en bleu) dont la base est justement l'ellipse. On peut alors voir, même si ce
            n'est pas du tout évident ici car il s'agissait d'une vidéo à la base, que des ellipses vont venir paver
            le cone sur toute sa périphérie (environ à mi hauteur). Sur chacune des ces ellipses va passer une
            hyperbole, et les couches se placeront perpendiculairement aux Cyclides. Tout le but du projet de ce
            stage était de modéliser ce phénomène, et de voir si on pouvait reproduire ec que l'on voyait avec les
            équations bien connues de la physique des cristaux liquides.

        </div>
        <div class="part-content">
            <h2><i class="fas fa-chevron-right chevron-color"></i> Création du programme</h2>

            En premier lieu ce programme fut écrit en langage Mathematica, mais a fini par se faire en Python pour
            des souci de prix, et de distribution. La preuve est que je ne peux plus acceder au code de mon notebook car je
            n'ai plus ce logiciel.

            <h3><i class="fas fa-chevron-right chevron-color"></i> Creation de fonctions qui permettent de faire des
                rotations dans l'espace</h3>
            Suite à ce manque dans les librairies Python et Numpy, j'ai donc du coder deux fonctions permettant de
            faire une rotation dans l'espace selon un des 3 axes. Le code est disponible sur <a
                href="https://github.com/antscloud/rotplot"> <b>ce lien</b></a> et est directement téléchargeable via pypi
            <span class="inline-code2">
                <pre><code class="python">pip install rotplot</code></pre></span>.

            La première fonction rot_3D_surf permet de faire des rotations de surface en lui indiquant : la surface,
            l'angle et selon quel axe le faire. La deuxième, rot_3D permet de faire des rotation mais non plus de
            surface mais de figure en 3D, tel qu'une ellipse ou une hyperbole, elle prend les mêmes paramètres que la
            première.

            <pre>
    <code class="python">
import numpy as np

def rot_3D_surf(surf3D,angle,nR):
    '''
    Fonction that rotate a three-dimensional surface by an user-defined angle, 
    and around a given axis. 
    surf3D : Equation of the surface 
    nR = 0 Rotation around the x axis
    nR = 1 Rotation around the y axis
    nR = 2 Rotation around the z axis     
    '''
    theta = np.radians(angle)
    c=np.cos(theta)
    s=np.sin(theta)
    RX = np.array( ((1,0,0),(0,c,-s),(0,s, c) ))
    RY=np.array( ((c,0,s),(0,1,0),(-s,0, c) ))
    RZ=np.array( ((c,-s,0),(s,c,0),(0,0, 1) ))
    matrot=[RX,RY,RZ]

    surf_ROT=np.zeros(np.shape(surf3D))

    for j in np.arange(0,np.shape(surf3D)[2]):
        surf_rot_fun=[surf3D[0][j],surf3D[1][j],surf3D[2][j]]
        surf_rot_fun2=np.zeros(np.shape(surf_rot_fun))
        surf_rot_fun3=np.zeros(3)
        for i in np.arange(0,np.shape(surf3D)[1]):
            surf_rot_fun3=[surf_rot_fun[0][i],surf_rot_fun[1][i],surf_rot_fun[2][i]]
            surf_rot_fun2[:,i]=np.dot(surf_rot_fun3,matrot[nR])
        surf_ROT[0][j] = surf_rot_fun2[0]
        surf_ROT[1][j] = surf_rot_fun2[1]
        surf_ROT[2][j] = surf_rot_fun2[2]
    return surf_ROT

def rot_3D(surf,angle,nR):
    '''
    Fonction that rotate a two-dimensional surface (like an ellipse in space) by an user-defined angle,
    and around a given axis. 
    surf : Equation of the 3D curve 
    nR = 0 Rotation around the x axis
    nR = 1 Rotation around the y axis
    nR = 2 Rotation around the z axis     
    '''
    theta = np.radians(angle)
    c=np.cos(theta)
    s=np.sin(theta)
    RX = np.array( ((1,0,0),(0,c,-s),(0,s, c) ))
    RY=np.array( ((c,0,s),(0,1,0),(-s,0, c) ))
    RZ=np.array( ((c,-s,0),(s,c,0),(0,0, 1) ))
    matrot=[RX,RY,RZ]


    surf_ROT=np.zeros(np.shape(surf))

    for i in np.arange(0,np.shape(surf)[1]):
        surf_fun=[surf[0][i],surf[1][i],surf[2][i]]
        surf_ROT[:,i]=np.dot(surf_fun,matrot[nR])
    return surf_ROT
    </code>
</pre>
        </div>


        <div class="part-content">
            <h2><i class="fas fa-chevron-right chevron-color"></i> Déclaration du code principal et des variables
                importantes</h2>
                Dans le code suivant, certaines variables importantes physiques sont définies. Leurs définitions n'est pas importante pour la suite du code. 
                On met aussi les import de librairies nécessaires.  Enfin on met les équations des ellipses et des cyclides. Ces équations sont les équations telles que l'ellipse, l'hyperbole et les cyclides soit par rapport au plan x0y.

            <pre>
    <code class="python">
from mpl_toolkits.mplot3d import Axes3D 
import numpy as np
import matplotlib.pyplot as plt

#demi grand axe
a=5 

#demi petit axe
b=3.4

#Paramètre de l'ellipse
c = np.sqrt(a**2 - b**2)

#Rayon
R=a

#Nombre d'ellipses sur le cone
n=5
#ThetaY=Angle de Rotation selon y pour creer orientation du cone 
ThetaY=-np.arcsin( (b)/(R*np.tan(np.pi/n)) )

#ThetaZ=Angle de rotation selon z pour coller les ellipses
ThetaZ=-2*np.arctan( (b)/(R*np.sin(-ThetaY)) )

ThetaY=np.degrees(ThetaY)
ThetaZ=np.degrees(ThetaZ)

u = np.linspace(0, 2*np.pi, 100)
v = np.linspace(-1, 1.73, 100)

U4,V4 = np.meshgrid(np.linspace(0, 2*np.pi, 100),np.linspace(-1.5, 1.5, 100))
U2,V2 = np.meshgrid(np.linspace(0.98, 5.3, 100),np.linspace(-1, 1, 100))
U6,V6 = np.meshgrid(np.linspace(0, 2*np.pi, 100),np.linspace(0.61, 1.5, 100))


Ellipse=[a * np.cos(u),  b*np.sin(u),np.zeros(len(u))]
Hyperbole=[-c*np.cosh(v),np.zeros(len(v)),b*np.sinh(v)]

Cyclide4=[-c*np.cosh(V4)+( (-4+a*np.cosh(V4))*(-a*np.cos(U4)+c*np.cosh(V4)) )/( -c*np.cos(U4) + a*np.cosh(V4) ),
            ( b*( -4 + a*np.cosh(V4) ) * np.sin(U4) ) / ( -c*np.cos(U4) + a* np.cosh(V4)  ),
            b*np.sinh(V4) - ( b*( -4 +a*np.cosh(V4) )*np.sinh(V4) ) / ( -c * np.cos(U4) + a*np.cosh(V4)  )]

Cyclide6=[-c*np.cosh(V6)+( (-6+a*np.cosh(V6))*(-a*np.cos(U6)+c*np.cosh(V6)) )/( -c*np.cos(U6) + a*np.cosh(V6) ),
            ( b*( -6 + a*np.cosh(V6) ) * np.sin(U6) ) / ( -c*np.cos(U6) + a* np.cosh(V6)  ),
            b*np.sinh(V6) - ( b*( -6 +a*np.cosh(V6) )*np.sinh(V6) ) / ( -c * np.cos(U6) + a*np.cosh(V6)  )]

Cyclide2=[-c*np.cosh(V2)+( (-2+a*np.cosh(V2))*(-a*np.cos(U2)+c*np.cosh(V2)) )/( -c*np.cos(U2) + a*np.cosh(V2) ),
            ( b*( -2 + a*np.cosh(V2) ) * np.sin(U2) ) / ( -c*np.cos(U2) + a* np.cosh(V2)  ),
            b*np.sinh(V2) - ( b*( -2 +a*np.cosh(V2) )*np.sinh(V2) ) / ( -c * np.cos(U2) + a*np.cosh(V2)  )]

    </code>
</pre>

            Ceci crée la figure suivante :
            <div class="d-flex flex-column align-items-center justify-content-center">
                <img src="image/ellipsemaplt.png" alt="Cyclide de Dupin Cristal liquide">
            </div>
        </div>


        <div class="part-content">
            <h2><i class="fas fa-chevron-right chevron-color"></i> Rotation de l'ellipse et décalage</h2>
            Afin de faire une rotation et de placer les ellipses sur un cône, on va en premier lieu faire une rotation selon y (car le repère est indirect) afin que la figure se redresse vers z.
            on la décale ensuite selon y d'une distance R qui correspondra au rayon du cône à l'abscisse z=0.

            <pre>
    <code class="python">
ER=Rot3D(Ellipse,ThetaY,1)
HR=Rot3D(Hyperbole,ThetaY,1)
CR2=Rot3DSurf(Cyclide2,ThetaY,1)
CR4=Rot3DSurf(Cyclide4,ThetaY,1)
CR6=Rot3DSurf(Cyclide6,ThetaY,1)

ER[0]=-R+ER[0]
HR[0]=-R+HR[0]
CR2[0]=-R+CR2[0]
CR4[0]=-R+CR4[0]
CR6[0]=-R+CR6[0]
        
    </code>
</pre>
            <div class="d-flex flex-column align-items-center justify-content-center">
                <img src="image/ellipsemapltdecal.png" alt="Cyclide de Dupin Cristal liquide">
            </div>
        </div>

        <div class='part-content'>
            <h2><i class="fas fa-chevron-right chevron-color"></i> Résultats</h2>

            Enfin après avoir effectué cette rotation, il a fallu recopier cette figure, et la tourner selon z jusqu'à ce qu'elle touche en un unique point l'autre ellipse et ainsi de suite. il fallait également que la dernière ellipse touche la premiere sans la chevaucher ce qui constistue un exercice mathémtique très compliqué. Aussi il fallait que tout les hyperboles se rejoingent en un seul point. 
            Une des étapes très compliqué était de trouver les angles de rotation tel qu'ils permettaient que les ellipses ne se touche qu'en un point et qu'elles ne se chevauchent pas.  
            Après de longues heures de travail, de réflexion et de manipulation d'objet imaginaire dans ma tête, je suis parvenu à trouver une situation pour laquelle on peut reproduire l'expérience. En effet la manipulation d'angle est ici très compliqué. Cependant, il reste une limitation qui est que le rayon en z=0 doit être égale au demi grand axe de l'ellipse. Des hypothèses de solution ont été soulevées (voir le github) mais sont très difficile à mettre en place.  
            <pre>
    <code class="python">
fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')
ax.set_axis_on()
ax.set_xlim(-15, 15)
ax.set_ylim(-15, 15)
ax.set_zlim(-10, 10)


for i in np.arange(1,n+1):
    ERZ=Rot3D(ER,i*ThetaZ,2)
    HRZ=Rot3D(HR,i*ThetaZ,2)
    CR2Z=Rot3DSurf(CR2,i*ThetaZ,2)
    CR4Z=Rot3DSurf(CR4,i*ThetaZ,2)
    CR6Z=Rot3DSurf(CR6,i*ThetaZ,2)
    ax.plot(ERZ[0], ERZ[1], ERZ[2])
    ax.plot(HRZ[0], HRZ[1], HRZ[2])
    ax.plot_surface(CR2Z[0], CR2Z[1], CR2Z[2])
    ax.plot_surface(CR4Z[0], CR4Z[1], CR4Z[2])
    ax.plot_surface(CR6Z[0], CR6Z[1], CR6Z[2])
    
plt.show()
    </code>
</pre>
            
            <div class="d-flex flex-column align-items-center justify-content-center">
                <img src="image/final3.gif" alt="Cyclide de Dupin Cristal liquide">
            </div>
        </div>

    </div>


    <!-- FOOTER -->
    <div class="footer d-flex justify-content-center" id="contact">

        <div id="svg-triangle-footer">
            <svg height="75" width="200">
                <polygon points="0,0 200,0 100,75" style="fill:#037B89;" />
            </svg>
        </div>

        <div class="d-flex align-items-center justify-content-center" id='footerlogocontainer'>

            <div class="d-flex flex-column justify-content-center align-items-center">
                <a class="d-flex flex-column justify-content-center align-items-center"
                    href="https://www.linkedin.com/in/antoine-gibek-7739a9169/"><i class="fab fa-linkedin"></i>
                    <span>Linkedin</span>
                </a>
            </div>

            <div class="d-flex flex-column align-items-center">
                <i class="fas fa-envelope"></i>
                <span>antoine.gibek(at)gmail.com</span>
            </div>

            <div class="d-flex flex-column justify-content-center align-items-center">
                <a class="d-flex flex-column justify-content-center align-items-center"
                    href="https://github.com/antscloud/"><i class="fab fa-github"></i>
                    <span>Github</span>
                </a>
            </div>

        </div>
    </div>

    <!-- FOOTER -->
</body>
<script>
    if (window.matchMedia("(max-width: 700px)").matches) {
        svg = document.getElementsByTagName('svg')
        svg[0].setAttribute("height", "50")
        svg[0].setAttribute("width", "100")
        svg[0].getElementsByTagName('polygon')[0].setAttribute("points", "0,0 100,0 50,50")

        svg[1].setAttribute("height", "50")
        svg[1].setAttribute("width", "100")
        svg[1].getElementsByTagName('polygon')[0].setAttribute("points", "0,0 100,0 50,50")
    } else {
    }

    document.getElementById('contactbutton').addEventListener('click',
        function () {
            document.getElementById('svg-triangle-footer').style.animationName = 'highlight-footer';
        }
    )
</script>
<script src="js/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</html>